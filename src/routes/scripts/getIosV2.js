module.exports = async function process(req, res) {
  const literal = '%@';
  res.json({
    getResult: `(()=>{ return result })()`,
    createTrade: `var result = {success: false, error: 'try again'}; (async () => { const url = new URL(window.location.href); const token = url.searchParams.get('token'); const meAssets = ${literal}; const themAssets = ${literal}; let postData = { tradeoffermessage: 'skinswipe', sessionid: g_sessionID, serverid: 1, cancelTime: 12 * 60 * 60 * 1000, partner: g_ulTradePartnerSteamID, json_tradeoffer: JSON.stringify({ newversion: true, version: 2, me: { assets: meAssets, currency: [], ready: true }, them: { assets: themAssets, currency: [], ready: false } }), captcha: '', trade_offer_create_params: JSON.stringify({trade_offer_access_token: token}) }; let xhr = new XMLHttpRequest(); xhr.open('POST', 'https://steamcommunity.com/tradeoffer/new/send', true); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded; charset=UTF-8'); xhr.onload = function () { if (xhr.status === 200) { result = { success: true, data: JSON.parse(xhr.responseText) }; } else { result = { success: false, error: (JSON.parse(xhr.responseText)).strError }; } }; let out = []; for (let key in postData) { out.push(key + '=' + encodeURIComponent(postData[key])) } out = out.join('&'); xhr.send(out); })();`,
    createTradeWithComment: `var result = {success: false, error: 'try again'}; (async () => { const url = new URL(window.location.href); const token = url.searchParams.get('token'); const meAssets = ${literal}; const themAssets = ${literal}; let postData = { tradeoffermessage: '${literal}', sessionid: g_sessionID, serverid: 1, cancelTime: 12 * 60 * 60 * 1000, partner: g_ulTradePartnerSteamID, json_tradeoffer: JSON.stringify({ newversion: true, version: 2, me: { assets: meAssets, currency: [], ready: true }, them: { assets: themAssets, currency: [], ready: false } }), captcha: '', trade_offer_create_params: JSON.stringify({trade_offer_access_token: token}) }; let xhr = new XMLHttpRequest(); xhr.open('POST', 'https://steamcommunity.com/tradeoffer/new/send', true); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded; charset=UTF-8'); xhr.onload = function () { if (xhr.status === 200) { result = { success: true, data: JSON.parse(xhr.responseText) }; } else { result = { success: false, error: (JSON.parse(xhr.responseText)).strError }; } }; let out = []; for (let key in postData) { out.push(key + '=' + encodeURIComponent(postData[key])) } out = out.join('&'); xhr.send(out); })();`,
    acceptTrade: `var result = {success: false, error: 'try again'}; (async () => { const url = new URL(window.location.href); const arr = url.pathname.split('/'); const tradeofferid = arr[arr.length-2]; let postData = { sessionid: g_sessionID, serverid: 1, tradeofferid, partner: g_ulTradePartnerSteamID, captcha: '' }; let xhr = new XMLHttpRequest(); xhr.open('POST', 'https://steamcommunity.com/tradeoffer/'+tradeofferid+'/accept', true); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded; charset=UTF-8'); xhr.onload = function () { if (xhr.status === 200) { result = { success: true, data: JSON.parse(xhr.responseText) }; } else { result = { success: false, error: (JSON.parse(xhr.responseText)).strError }; } }; let out = []; for (let key in postData) { out.push(key + '=' + encodeURIComponent(postData[key])) } out = out.join('&'); xhr.send(out); })();`,
    getStatus: `(function () { const tradeID = '${literal}'; if (document.getElementById('tradeofferid_' + tradeID)) { if (document.querySelector('#tradeofferid_' + tradeID + ' .tradeoffer_items_rule')) { return { status: 'error', result: 'not_confirmed', message: 'trade not confirmed' }; } const tradeDiv = document.querySelector('#tradeofferid_' + tradeID + ' .tradeoffer_items_banner'); let text1 = 'no tradeDiv'; if (tradeDiv) { text1 = document.querySelector('#tradeofferid_' + tradeID + ' .tradeoffer_items_banner').innerText; } if (tradeDiv && tradeDiv.className.replace(/[\\n\\t]/g).indexOf('accepted') > -1) { return { status: 'success', result: 'accepted', message: text1 }; } else if (tradeDiv && tradeDiv.className.replace(/[\\n\\t]/g).indexOf('in_escrow') > -1) { return { status: 'success', result: 'hold', message: text1 }; } return { status: 'success', result: 'rejected', message: text1 }; } return { status: 'error', result: 'not_found' }; })();`,
    getApiKey: `var result = { status: "success", message: "try again" }; (() => { if (document.getElementsByName("Revoke").length > 0) { const keyContent = document.getElementById("BG_bottom").innerHTML; let resText = keyContent.substring(keyContent.indexOf(": ") + 2, keyContent.indexOf("</p>")); if (resText.length > 0) { result = { status: "success", result: resText }; } else { result = { status: "error" }; } } else { let postData = { sessionid: g_sessionID, serverid: 1, domain: "localhost", agreeToTerms: "agreed" }; let xhr = new XMLHttpRequest(); xhr.open("POST", "https://steamcommunity.com/dev/registerkey", true); xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8"); xhr.onload = function () { if (xhr.status === 200) { const body = xhr.responseText; let resText = body.substring(body.lastIndexOf("bodyContents_ex"), body.lastIndexOf('form class="smallForm')); resText = resText.substring(resText.indexOf(": ") + 2, resText.indexOf("</p>")); if (resText.length > 0) { result = { status: "success", result: resText }; } else { result = { status: "error" }; } } else { result = { status: "error" }; } }; let out = []; for (let key in postData) { out.push(key + "=" + encodeURIComponent(postData[key])); } out = out.join("&"); xhr.send(out); } })();`,

    loginSetCookie: `document.cookie='steamMachineAuthEsliChestno=gabenloh';`,
    loginRememberClick: `document.getElementById('remember_login').click();`,

    userGetData: `(function () { return (document.getElementsByTagName('pre')[0].innerHTML); })();`,

    userGetTradeURL: `(function() { return (document.getElementById('trade_offer_access_url').value); })();`,

    getBanText: `(function() { let el = document.getElementsByClassName('help_highlight_bans_text')[0]; if (el) { return JSON.stringify({ status: 'error', message: el.innerText }); } return JSON.stringify({ status: 'success', message: 'not found' }); })();`,
    getPersonaname: `(function(){ let ss = 'SkinSwipe'; let input = document.querySelector('input[name=personaName]'); if (!input || !input.value) { return { status: 'error', code: 1, message: 'HTML entities not found' }; } return { status: 'success', result: input.value }; })();`,
    setPersonaname: `(function(){ let ss = 'SkinSwipe'; let input = document.querySelector('input[name=personaName]'); let button = document.querySelector('button.Primary'); if (!button || !input || !input.value){ return { status: 'error', code: 1, message: 'HTML entities not found' }; } let name = input.value; if (name.toLowerCase().indexOf(ss.toLowerCase()) !== -1) { return { status: 'success', result: name }; } if (name.length + ss.length > 30) { name = name.slice(0, 30 - ss.length); } name = name + '.' + ss; input.value = name; button.click(); return { status: 'success', result: name }; })();`,
    checkPersonaname: `(function(){ let ss = 'SkinSwipe'; let input = document.querySelector('input[name=personaName]'); if (!input || !input.value) { return { status: 'error', code: 1, message: 'HTML entities not found' }; } let name = input.value; if (name.toLowerCase().indexOf(ss.toLowerCase()) !== -1) { return { status: 'success', result: name }; } return { status: 'error', code: 2, message: 'SkinSwipe not found' }; })();`,
    checkTradeBan: `(function(){ let texts = document.getElementsByClassName('error_page_content'); if (!texts.length) { return { status: 'success' }; } let text = texts[0].innerText; let matches = text.split(':'); if (matches.length > 1) { text = matches[1]; } return { status: 'error', code: 1, message: text }; })();`,
    getFriendsSteamIds: `(function(){ var persons = document.getElementsByClassName('persona'); var steamIds = []; for (var i = 0; i < persons.length; i++) { if (persons[i] && persons[i].dataset.steamid) { steamIds.push(persons[i].dataset.steamid); } } return steamIds; })();`,
  });
};
